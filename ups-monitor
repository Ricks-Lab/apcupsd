#!/usr/bin/env python3
""" ups-monitor  -  Displays current status of all active UPSs

    A utility to give the current state of all compatible UPSs. The default behavior
    is to continuously update a text based table in the current window until Ctrl-C is
    pressed.  With the *--gui* option, a table of relevant parameters will be updated
    in a Gtk window.  You can specify the delay between updates with the *--sleep N*
    option where N is an integer > 10 that specifies the number of seconds to sleep
    between updates.  The *--log* option is used to write all monitor data to a psv log
    file.  When writing to a log file, the utility will indicate this in red at the top of
    the window with a message that includes the log file name.  The *--status* option will
    output a table of the current status.  The *--long* option will include additional
    informational parameters. By default, unresponsive UPSs will not be displayed, but the
    *--show_unresponsive* can be used to force their display.

    Copyright (C) 2019  RueiKe

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
__author__ = 'RueiKe'
__copyright__ = 'Copyright (C) 2019 RueiKe'
__credits__ = ['']
__license__ = 'GNU General Public License'
__program_name__ = 'ups-monitor'
__version__ = 'v0.9.0'
__maintainer__ = 'RueiKe'
__status__ = 'Beta Release'

import argparse
import threading
import os
import sys
import re
import time
from UPSmodules import UPSmodule as UPS
from UPSmodules import env
from config import (threshold_battery_load_red, threshold_battery_load_yellow,
                    threshold_battery_capacity_red, threshold_battery_capacity_yellow)

try:
    import gi
except ModuleNotFoundError as error:
    print('gi import error: {}'.format(error))
    print('gi is required for %s', __program_name__)
    print('   In a venv, first install vext:  pip install --no-cache-dir vext')
    print('   Then install vext.gi:  pip install --no-cache-dir vext.gi')
    sys.exit(0)
gi.require_version('Gtk', '3.0')
from gi.repository import GLib, Gtk, Gdk


class MonitorWindow(Gtk.Window):
    def __init__(self, ups, header_items, command_items, devices):
        self.quit = False

        Gtk.Window.__init__(self, title='ups-monitor')
        self.set_border_width(1)
        icon_file = os.path.join(env.ut_const.icon_path, 'ups-monitor.icon.png')
        if env.ut_const.DEBUG: print('Icon file: [{}]'.format(icon_file))
        if os.path.isfile(icon_file):
            self.set_icon_from_file(icon_file)
        grid = Gtk.Grid()
        grid.override_background_color(Gtk.StateType.NORMAL, Gdk.RGBA(1, 1, 1, 1))
        self.add(grid)

        col = 0
        row = 0
        if env.ut_const.show_unresponsive:
            num_ups = ups.get_num_ups_tuple()[0]
        else:
            num_ups = ups.get_num_ups_tuple()[3]

        # Set logging details at top of table if logging enabled
        if env.ut_const.LOG:
            log_label = Gtk.Label()
            log_label.set_markup('<big><b> Logging to:    </b>' + env.ut_const.log_file + '</big>')
            log_label.override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(1.0, 1.0, 1.0, 1.0))
            lbox = Gtk.Box(spacing=6)
            lbox.override_background_color(Gtk.StateType.NORMAL, Gdk.RGBA(.60, .20, .20, 1.0))
            lbox.set_property('margin-top', 1)
            lbox.set_property('margin-bottom', 1)
            lbox.set_property('margin-right', 1)
            lbox.set_property('margin-left', 1)
            lbox.pack_start(log_label, True, True, 0)
            grid.attach(lbox, 0, row, num_ups + 1, 1)
        row += 1
        row_start = row

        # Set first column of table to static values
        row = row_start
        row_labels = {'display_name': Gtk.Label()}
        row_labels['display_name'].set_markup('<b>UPS Parameters</b>')
        row_labels['display_name'].override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(1.0, 1.0, 1.0, 1.0))
        # Set row labels for header items
        for v in header_items:
            row_labels[v] = Gtk.Label()
            row_labels[v].set_markup('<b>' + str(ups.get_mib_name(v)) + '</b>')
            row_labels[v].override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(1.0, 1.0, 1.0, 1.0))
        # Set row labels for command items
        for v in command_items:
            row_labels[v] = Gtk.Label()
            row_labels[v].set_markup('<b>' + str(ups.get_mib_name(v)) + '</b>')
            row_labels[v].override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(1.0, 1.0, 1.0, 1.0))
        # Set boxes for each row label
        for k, v in row_labels.items():
            lbox = Gtk.Box(spacing=6)
            lbox.override_background_color(Gtk.StateType.NORMAL, Gdk.RGBA(.20, .40, .60, 1.0))
            lbox.set_property('margin-top', 1)
            lbox.set_property('margin-bottom', 1)
            lbox.set_property('margin-right', 1)
            lbox.set_property('margin-left', 1)
            v.set_property('margin-top', 1)
            v.set_property('margin-bottom', 1)
            v.set_property('margin-right', 4)
            v.set_property('margin-left', 4)
            lbox.pack_start(v, True, True, 0)
            grid.attach(lbox, col, row, 1, 1)
            v.set_alignment(0, 0.5)
            row += 1

        # Associate all table items with data source in devices dictionary
        for item_name, item_ups in ups.get_ups_list(errups=env.ut_const.show_unresponsive).items():
            devices[item_ups['uuid']] = {'display_name':  Gtk.Label(ups.ups_name(item_ups))}
            for item_hdr in header_items:
                devices[item_ups['uuid']][item_hdr] = Gtk.Label(label=ups.get_ups_parameter_value(item_hdr, item_ups))
                devices[item_ups['uuid']][item_hdr].set_width_chars(10)
            for item_cmd in command_items:
                devices[item_ups['uuid']][item_cmd] = Gtk.Label(label=ups.get_ups_parameter_value(item_cmd, item_ups))
                devices[item_ups['uuid']][item_cmd].set_width_chars(10)

        # Set boxes for internal table items
        for dk, dv in devices.items():
            col += 1
            row = row_start
            for lk, lv in dv.items():
                lv.set_text('')
                lbox = Gtk.Box(spacing=6)
                if row == row_start:
                    lbox.override_background_color(Gtk.StateType.NORMAL, Gdk.RGBA(.20, .40, .60, 1.0))
                else:
                    lbox.override_background_color(Gtk.StateType.NORMAL, Gdk.RGBA(.06, .06, .06, .06))
                lbox.set_property('margin-top', 1)
                lbox.set_property('margin-bottom', 1)
                lbox.set_property('margin-right', 1)
                lbox.set_property('margin-left', 1)
                lv.set_property('margin-top', 1)
                lv.set_property('margin-bottom', 1)
                lv.set_property('margin-right', 3)
                lv.set_property('margin-left', 3)
                lv.set_width_chars(17)
                lbox.pack_start(lv, True, True, 0)
                grid.attach(lbox, col, row, 1, 1)
                row += 1

    def set_quit(self, _arg2, _arg3):
        self.quit = True


def updateData(ups, header_list, command_list, devices):
    irw = 20
    ups_data = ups.read_all_ups_list_items(command_list, errups=env.ut_const.show_unresponsive)
    if env.ut_const.LOG:
        print_log(env.ut_const.log_file_ptr, header_list, command_list, ups_data)

    # update gui
    for dev_uuid, dev_data in devices.items():
        ups_name = ups.get_name_for_ups_uuid(dev_uuid)
        for mib_name, lv in dev_data.items():
            data_value = str(ups_data[ups_name][mib_name])[:irw]
            if data_value == '-1':
                data_value = ''
            if mib_name == 'mib_battery_capacity' and data_value.isnumeric():
                if int(data_value) <= threshold_battery_capacity_red:
                    lv.override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(.70, .20, .20, 1.0))
                    lv.set_markup('<b>{}</b>'.format(data_value))
                elif int(data_value) >= threshold_battery_capacity_yellow:
                    lv.override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(.90, .50, .00, 1.0))
                    lv.set_markup('<b>{}</b>'.format(data_value))
                else:
                    lv.override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(0.3, 0.3, 0.3, 1.0))
                    lv.set_text(data_value)
            if mib_name == 'mib_output_load' and data_value.isnumeric():
                if int(data_value) >= threshold_battery_load_red:
                    lv.override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(.70, .20, .20, 1.0))
                    lv.set_markup('<b>{}</b>'.format(data_value))
                elif int(data_value) >= threshold_battery_load_yellow:
                    lv.override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(.90, .50, .00, 1.0))
                    lv.set_markup('<b>{}</b>'.format(data_value))
                else:
                    lv.override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(0.3, 0.3, 0.3, 1.0))
                    lv.set_text(data_value)
            elif mib_name == 'mib_battery_status':
                lv.override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(1.0, 1.0, 1.0, 1.0))
                lv.set_markup('<b>{}</b>'.format(data_value))
                if re.match(r'(.*Battery Normal.*)', data_value):
                    lv.override_background_color(Gtk.StateType.NORMAL, Gdk.RGBA(.20, .60, .40, 1.0))
                else:
                    lv.override_background_color(Gtk.StateType.NORMAL, Gdk.RGBA(.60, .20, .20, 1.0))
            elif mib_name == 'mib_system_status':
                lv.override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(1.0, 1.0, 1.0, 1.0))
                lv.set_markup('<b>{}</b>'.format(data_value))
                if re.match(r'(.*Standby.*)|(.*OnLine.*)', data_value):
                    lv.override_background_color(Gtk.StateType.NORMAL, Gdk.RGBA(.20, .60, .40, 1.0))
                else:
                    lv.override_background_color(Gtk.StateType.NORMAL, Gdk.RGBA(.60, .20, .20, 1.0))
            elif mib_name == 'display_name':
                lv.override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(1.0, 1.0, 1.0, 1.0))
                lv.set_markup('<b>{}</b>'.format(data_value))
            else:
                lv.override_color(Gtk.StateFlags.NORMAL, Gdk.RGBA(0.3, 0.3, 0.3, 1.0))
                lv.set_text(data_value)
            lv.set_width_chars(irw + 1)

    while Gtk.events_pending():
        Gtk.main_iteration_do(True)


def refresh(refreshtime, updateData, ups, header_list, command_list, devices, umonitor):
    while True:
        if umonitor.quit:
            print('Quitting...')
            Gtk.main_quit()
            sys.exit(0)
        GLib.idle_add(updateData, ups, header_list, command_list, devices)
        time.sleep(refreshtime)


def print_monitor_table(ups, header_list, cmd_list, ups_data):
    num_ups = ups.get_num_ups_tuple()
    if num_ups[0] < 1:
        return -1

    hrw = 29
    irw = 24

    print('┌', '─'.ljust(hrw, '─'), sep='', end='')
    for _, _ in ups_data.items():
        print('┬', '─'.ljust(irw, '─'), sep='', end='')
    print('┐')

    print('│', '\x1b[1;36m' + 'UPS Parameters'.ljust(hrw, ' ') + '\x1b[0m', sep='', end='')
    for k, v in ups_data.items():
        print('│', '\x1b[1;36m' + v['display_name'].ljust(irw, ' ') + '\x1b[0m',
              sep='', end='')
    print('│')

    print('├', '─'.ljust(hrw, '─'), sep='', end='')
    for _, _ in ups_data.items():
        print('┼', '─'.ljust(irw, '─'), sep='', end='')
    print('┤')

    for info_item in header_list:
        print('│', '\x1b[1;36m' + info_item.ljust(hrw, ' ')[:hrw] + '\x1b[0m',
              sep='', end='')
        for k, v in ups_data.items():
            print('│', str(v[info_item]).ljust(irw, ' ')[:irw], sep='', end='')
        print('│')
    for table_item in cmd_list:
        print('│', '\x1b[1;36m' + ups.get_mib_name_for_type(table_item, 'apc-ap9630').ljust(hrw, ' ')[:hrw] + '\x1b[0m',
              sep='', end='')
        for k, v in ups_data.items():
            if table_item == 'mib_system_status':
                if re.match(r'(.*Standby.*)|(.*OnLine.*)', v[table_item]):
                    item_str = '\x1b[1;30;42m' + v[table_item].ljust(irw, ' ')[:irw] + '\x1b[0m'
                else:
                    item_str = '\x1b[1;37;41m' + v[table_item].ljust(irw, ' ')[:irw] + '\x1b[0m'
            elif table_item == 'mib_battery_status':
                if re.match(r'(.*Battery Normal.*)', v[table_item]):
                    item_str = '\x1b[1;30;42m' + v[table_item].ljust(irw, ' ')[:irw] + '\x1b[0m'
                else:
                    item_str = '\x1b[1;37;41m' + v[table_item].ljust(irw, ' ')[:irw] + '\x1b[0m'
            else:
                item_str = str(v[table_item]).ljust(irw, ' ')[:irw]
            print('│', item_str, sep='', end='')
        print('│')

    print('└', '─'.ljust(hrw, '─'), sep='', end='')
    for _, _ in ups_data.items():
        print('┴', '─'.ljust(irw, '─'), sep='', end='')
    print('┘')


def print_log(fileptr, header_list, command_list, ups_data):
    time_str = (str(env.ut_const.now(ltz=True).strftime('%c')).strip())
    for k, v in ups_data.items():
        print('{}'.format(time_str), file=fileptr, end='')
        for item in header_list:
            print('|{}'.format(v[item]), file=fileptr, end='')
        for item in command_list:
            print('|{}'.format(v[item]), file=fileptr, end='')
        print('', file=fileptr)


def print_log_header(fileptr, header_list, command_list):
    print('time', file=fileptr, end='')
    for item in header_list:
        print('|{}'.format(item), file=fileptr, end='')
    for item in command_list:
        print('|{}'.format(item), file=fileptr, end='')
    print('', file=fileptr)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--about', help='README', action='store_true', default=False)
    parser.add_argument('--status', help='Display table of current status of UPSs', action='store_true', default=False)
    parser.add_argument('--long', help='Include static items', action='store_true', default=False)
    parser.add_argument('--show_unresponsive', help='Display unresponsive UPSs', action='store_true', default=False)
    parser.add_argument('--gui', help='Display GTK Version of Monitor', action='store_true', default=False)
    parser.add_argument('--log', help='Write all monitor data to logfile', action='store_true', default=False)
    parser.add_argument('--sleep', help='Number of seconds to sleep between updates', type=int, default=15)
    parser.add_argument('-d', '--debug', help='Debug output', action='store_true', default=False)
    args = parser.parse_args()

    # About me
    if args.about:
        print(__doc__)
        print('Author: ', __author__)
        print('Copyright: ', __copyright__)
        print('Credits: ', __credits__)
        print('License: ', __license__)
        print('Version: ', __version__)
        print('Maintainer: ', __maintainer__)
        print('Status: ', __status__)
        sys.exit(0)

    env.ut_const.DEBUG = args.debug

    if env.ut_const.check_env() < 0:
        print('Error in environment. Exiting...')
        sys.exit(-1)

    print('Reading and verifying UPSs listed in config.json')
    ups = UPS.UPSsnmp()
    num_ups = ups.get_num_ups_tuple()

    if num_ups[0] == 0:
        print('No UPSs specified in config.json, exiting...')
        sys.exit(-1)
    print('{} UPSs listed in config.json file.'.format(num_ups[0]))
    print('    {} are compatible, {} are accessible, {} are responsive'.format(num_ups[1], num_ups[2], num_ups[3]))
    if not num_ups[0] == num_ups[3]:
        print('    Check the config.json file.')
    print('')

    if int(args.sleep) >= env.ut_const.DEFAULT_MONITOR_UPDATE_INTERVAL:
        env.ut_const.SLEEP = int(args.sleep)
    else:
        print('Invalid value for sleep specified.  Must be an integer >= {}'.format(
              env.ut_const.DEFAULT_MONITOR_UPDATE_INTERVAL))
        sys.exit(-1)

    header_list = ['ups_type', 'ups_IP']
    if args.long:
        command_list = ups.get_monitor_mib_commands('all')
    else:
        command_list = ups.get_monitor_mib_commands()

    if args.show_unresponsive:
        env.ut_const.show_unresponsive = True
    else:
        env.ut_const.show_unresponsive = False

    if args.log:
        env.ut_const.LOG = True
        env.ut_const.log_file = './log_monitor_{}.txt'.format(
            env.ut_const.now(ltz=env.ut_const.USELTZ).strftime('%m%d_%H%M%S'))
        env.ut_const.log_file_ptr = open(env.ut_const.log_file, 'w', 1)
        print_log_header(env.ut_const.log_file_ptr, header_list, command_list)

    if args.gui:
        # print("GUI option not implemented yet")
        # sys.exit(0)
        # Display Gtk style Monitor
        devices = {}
        umonitor = MonitorWindow(ups, header_list, command_list, devices)
        umonitor.connect('delete-event', umonitor.set_quit)
        umonitor.show_all()

        # Start thread to update Monitor
        monthread = threading.Thread(target=refresh, daemon=True, args=[env.ut_const.SLEEP,
                                     updateData, ups, header_list, command_list, devices, umonitor]).start()

        Gtk.main()
    else:
        # Display text style Monitor
        try:
            while True:
                ups_data = ups.read_all_ups_list_items(command_list, errups=args.show_unresponsive)
                if args.status:
                    print_monitor_table(ups, header_list, command_list, ups_data)
                    sys.exit(0)
                if not env.ut_const.DEBUG: os.system('clear')
                if env.ut_const.LOG:
                    print('%sLogging to:  %s%s' % ('\033[31m \033[01m', env.ut_const.log_file, '\033[0m'))
                    print_log(env.ut_const.log_file_ptr, header_list, command_list, ups_data)
                print_monitor_table(ups, header_list, command_list, ups_data)
                time.sleep(env.ut_const.SLEEP)
        except KeyboardInterrupt:
            if env.ut_const.LOG:
                env.ut_const.log_file_ptr.close()
            sys.exit(0)


if __name__ == '__main__':
    main()
